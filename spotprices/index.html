<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rossohamn – Spotpriser (SE3)</title>

  <link rel="stylesheet" href="styles.css">

  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div>
          <div class="title">Rossohamn – Spotpriser</div>
          <div class="small">Källa: ENTSO-E A44 (SE3) → history.json</div>
        </div>
        <div class="row">
          <label class="small" for="src">Data-URL</label>
          <input id="src" style="min-width:180px; flex: 1 1 260px;" />
          <button id="reload" class="btn">Ladda</button>
        </div>
      </div>

      <div id="meta" class="meta" style="margin-top:10px;"></div>
    </div>

    <div class="card">
      <div class="row tabs">
        <button id="tab-today" class="active">Idag</button>
        <button id="tab-tomorrow">Imorgon</button>
        <button id="tab-day">Dag</button>
        <button id="tab-7d">7 dagar</button>
        <button id="tab-14d">14 dagar</button>
        <button id="tab-30d">30 dagar</button>

        <span style="flex:1;"></span>

        <label class="small" for="metric">Serie</label>
        <select id="metric">
          <option value="oreKwh" selected>öre/kWh</option>
          <option value="sekKwh">SEK/kWh</option>
          <option value="eurMwh">EUR/MWh</option>
        </select>

        <label class="toggle small" title="Fyll bara korta luckor (max 8 null i rad) med linjär interpolation. Rådata ändras inte.">
          <input id="fillGaps" type="checkbox" />
          Extrapolera null (≤8)
        </label>

        <label class="toggle small" title="Visa referenslinjer motsvarande 1/2/3 kr/kWh (omräknat till vald serie).">
          <input id="krLines" type="checkbox" />
          1/2/3 kr-linjer
        </label>

        <label class="small" for="datePick">Datum</label>
        <select id="datePick"></select>

        <button id="prevDay" class="btn">←</button>
        <button id="nextDay" class="btn">→</button>
      </div>

      <div style="margin-top:10px;" class="chartWrap">
        <canvas id="chart"></canvas>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div style="font-weight:700;">Summering</div>
        <div class="small" id="summaryNote">Billigaste fönster kräver komplett fönster (inga null)</div>
      </div>
      <div id="summary" style="margin-top:10px;"></div>
    </div>

    <div class="card small">
      Tips: du kan byta datakälla via querystring:
      <span class="pill">?src=https://www.rossohamn.se/spotprices/history.json</span>
    </div>
  </div>

<script>
(() => {
  const DEFAULT_SRC = "history.json";
  const el = (id) => document.getElementById(id);

  const state = {
    data: null,
    tab: "today",          // today|tomorrow|day|7d|14d|30d
    selectedDate: null,
    metric: "oreKwh",
    fillGaps: false,
    krLines: false,
  };

  // ----- Time helpers -----
  function stockholmTodayIsoDate() {
    const parts = new Intl.DateTimeFormat("sv-SE", {
      timeZone: "Europe/Stockholm",
      year: "numeric", month: "2-digit", day: "2-digit"
    }).formatToParts(new Date());
    const y = parts.find(p => p.type === "year").value;
    const m = parts.find(p => p.type === "month").value;
    const d = parts.find(p => p.type === "day").value;
    return `${y}-${m}-${d}`;
  }

  function addDays(yyyyMmDd, deltaDays) {
    const [y,m,d] = yyyyMmDd.split("-").map(Number);
    const dt = new Date(Date.UTC(y, m-1, d));
    dt.setUTCDate(dt.getUTCDate() + deltaDays);
    const y2 = dt.getUTCFullYear();
    const m2 = String(dt.getUTCMonth()+1).padStart(2,"0");
    const d2 = String(dt.getUTCDate()).padStart(2,"0");
    return `${y2}-${m2}-${d2}`;
  }

  function slotToTime(slotIndex, resolutionMinutes) {
    const rm = Number(resolutionMinutes) || 15;
    const total = slotIndex * rm;
    const hh = Math.floor(total / 60) % 24;
    const mm = total % 60;
    return String(hh).padStart(2,"0") + ":" + String(mm).padStart(2,"0");
  }


  function getParam(name) {
    const u = new URL(location.href);
    return u.searchParams.get(name);
  }

  function fmtNum(v, decimals=2) {
    if (v === null || v === undefined || Number.isNaN(v)) return "—";
    return Number(v).toFixed(decimals);
  }

  function decimals() {
    // öre kan visas med 2, SEK/EUR med 4 för jämförelse
    return (state.metric === "oreKwh") ? 2 : 4;
  }

  function unitLabel() {
    switch (state.metric) {
      case "oreKwh": return "öre/kWh";
      case "sekKwh": return "SEK/kWh";
      case "eurMwh": return "EUR/MWh";
      default: return state.metric;
    }
  }

  // Convert "1 SEK/kWh" reference lines into the currently selected unit.
  function sekKwhToMetricY(sekKwhValue) {
    if (typeof sekKwhValue !== "number") return null;

    if (state.metric === "sekKwh") return sekKwhValue;
    if (state.metric === "oreKwh") return sekKwhValue * 100.0;

    if (state.metric === "eurMwh") {
      const eursek = Number(state.data?.meta?.eursek);
      if (!eursek || Number.isNaN(eursek)) return null;

      // 1 SEK/kWh = 1000 SEK/MWh
      const sekPerMwh = sekKwhValue * 1000.0;
      const eurPerMwh = sekPerMwh / eursek;
      return eurPerMwh;
    }

    return null;
  }

  function computeStats(series) {
    const vals = series.filter(v => typeof v === "number");
    if (!vals.length) return { avg: null, min: null, max: null, count: 0 };
    let sum = 0, min = vals[0], max = vals[0];
    for (const v of vals) {
      sum += v;
      if (v < min) min = v;
      if (v > max) max = v;
    }
    return { avg: sum / vals.length, min, max, count: vals.length };
  }

  // Fill short gaps (internal only) with linear interpolation.
  function fillSmallGapsLinear(values, maxGap = 8) {
    const out = values.slice();
    let i = 0;

    while (i < out.length) {
      if (typeof out[i] === "number") { i++; continue; }

      const gapStart = i;
      while (i < out.length && typeof out[i] !== "number") i++;
      const gapEnd = i - 1;
      const gapLen = gapEnd - gapStart + 1;

      if (gapLen > maxGap) continue;

      const leftIdx = gapStart - 1;
      const rightIdx = gapEnd + 1;
      if (leftIdx < 0 || rightIdx >= out.length) continue;

      const left = out[leftIdx];
      const right = out[rightIdx];
      if (typeof left !== "number" || typeof right !== "number") continue;

      const step = (right - left) / (gapLen + 1);
      for (let k = 1; k <= gapLen; k++) {
        out[gapStart + (k - 1)] = left + step * k;
      }
    }
    return out;
  }

  // ----- Data builders -----
  function buildDayLabels(day) {
    return day.points.map(p => p ? p.time : "");
  }

  function buildDaySeries(day) {
    return day.points.map(p => (p && typeof p[state.metric] === "number") ? p[state.metric] : null);
  }

  function buildRangeKeys(nDays) {
    const keys = Object.keys(state.data?.days || {}).sort();
    if (!keys.length) return [];
    return keys.slice(-nDays);
  }

  function buildRangeLabelsAndSeries(keys) {
    const labels = [];
    const series = [];
    const refs = []; // {dayKey,time}

    for (const dayKey of keys) {
      const day = state.data.days[dayKey];
      if (!day?.points) continue;

      for (let i = 0; i < day.points.length; i++) {
        const p = day.points[i];
        const t = slotToTime(i, day.resolutionMinutes);
        labels.push(`${dayKey.slice(5)} ${t}`);
        series.push((p && typeof p[state.metric] === "number") ? p[state.metric] : null);
        refs.push({ dayKey, time: t });
      }
    }
    return { labels, series, refs };
  }

  // Cheapest continuous window over a series (no nulls in window).
  function cheapestWindow(series, slots) {
    let best = null;
    for (let i = 0; i <= series.length - slots; i++) {
      let ok = true;
      let sum = 0;
      for (let k = 0; k < slots; k++) {
        const v = series[i+k];
        if (typeof v !== "number") { ok = false; break; }
        sum += v;
      }
      if (!ok) continue;
      const avg = sum / slots;
      if (!best || avg < best.avg) best = { startIdx: i, endIdx: i + slots - 1, avg };
    }
    return best;
  }

  function buildHighlightSeries(series, win) {
    if (!win) return null;
    const out = series.map(() => null);
    for (let i = win.startIdx; i <= win.endIdx; i++) out[i] = series[i];
    return out;
  }

  // Rainbow-ish gradient for the main line (green -> blue -> red)
  function lineGradientColor(ctx) {
    const { chart } = ctx;
    const { ctx: c, chartArea } = chart;
    if (!chartArea) return "#9fd4ff";

    const g = c.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
    g.addColorStop(0.00, "#2ecc71"); // low
    g.addColorStop(0.50, "#3498db"); // mid
    g.addColorStop(1.00, "#e74c3c"); // high
    return g;
  }

  // "Now" vertical line for today's single-day view
  const nowLinePlugin = {
    id: "nowLine",
    afterDraw(chart) {
      if (state.tab !== "today") return;
      const xScale = chart.scales.x;
      if (!xScale) return;

      // 15-min resolution => 4 points/hour
      const now = new Date();
      const hh = Number(new Intl.DateTimeFormat("sv-SE", { timeZone: "Europe/Stockholm", hour: "2-digit" }).format(now));
      const mm = Number(new Intl.DateTimeFormat("sv-SE", { timeZone: "Europe/Stockholm", minute: "2-digit" }).format(now));
      const slot = hh * 4 + Math.floor(mm / 15);

      const x = xScale.getPixelForValue(slot);
      if (!Number.isFinite(x)) return;

      const ctx = chart.ctx;
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, chart.chartArea.top);
      ctx.lineTo(x, chart.chartArea.bottom);
      ctx.stroke();
      ctx.restore();
    }
  };

  Chart.register(nowLinePlugin);

  let chart = null;

  function windowTimeTextSingleDay(dayKey, day, win) {
    if (!win) return "—";
    const rm = day?.resolutionMinutes ?? 15;
    const start = slotToTime(win.startIdx, rm);
    const end = slotToTime(win.endIdx, rm);
    return `${dayKey} ${start} → ${dayKey} ${end}`;
  }

  function windowTimeTextRange(refs, win) {
    if (!win) return "—";
    const a = refs?.[win.startIdx];
    const b = refs?.[win.endIdx];
    if (!a?.dayKey || !a?.time || !b?.dayKey || !b?.time) return "—";
    return `${a.dayKey} ${a.time} → ${b.dayKey} ${b.time}`;
  }

  function renderSummary({ stats, win2h, win4h, win8h, infoText, timeText2h, timeText4h, timeText8h }) {
    const dec = decimals();

    el("summaryNote").textContent = state.fillGaps
      ? "Billigaste fönster kan använda extrapolerade punkter (≤8 null i rad). Rådata ändras inte."
      : "Billigaste fönster kräver komplett fönster (inga null).";

    const row = (label, win, hours, timeText) => {
      if (!win) return `
        <tr>
          <td>${label}</td><td>—</td><td>—</td><td>Inget komplett ${hours}h-fönster</td>
        </tr>`;
      return `
        <tr>
          <td>${label}</td>
          <td><b>${fmtNum(win.avg, dec)}</b> ${unitLabel()}</td>
          <td>${timeText}</td>
          <td>${state.fillGaps ? "Kan inkludera extrapolerade punkter" : "Endast rådata utan null"}</td>
        </tr>`;
    };

    el("summary").innerHTML = `
      <div class="row">
        <span class="pill">${infoText}</span>
        <span class="pill">Medel: <b>${fmtNum(stats.avg, dec)}</b> ${unitLabel()}</span>
        <span class="pill">Min: <b>${fmtNum(stats.min, dec)}</b></span>
        <span class="pill">Max: <b>${fmtNum(stats.max, dec)}</b></span>
        <span class="pill">Punkter: <b>${stats.count}</b></span>
        ${state.fillGaps ? `<span class="pill">Extrapolering: <b>ON</b> (≤8)</span>` : `<span class="pill">Extrapolering: <b>OFF</b></span>`}
      </div>

      <table style="margin-top:10px;">
        <thead><tr><th>Fönster</th><th>Medel</th><th>Tidsintervall</th><th>Not</th></tr></thead>
        <tbody>
          ${row("Billigaste 2h", win2h, 2, timeText2h)}
          ${row("Billigaste 4h", win4h, 4, timeText4h)}
          ${row("Billigaste 8h", win8h, 8, timeText8h)}
        </tbody>
      </table>
    `;
  }

  // Legend click: block toggling of the main price curve (men låt highlights 2h/4h/8h gå att slå av/på)
  function legendOnClick(e, legendItem, legend) {
    const chart = legend.chart;
    const idx = legendItem.datasetIndex;
    const ds = chart.data.datasets[idx];
    if (!ds) return;

    // Main series = första datasetet (label = unitLabel())
    if (idx === 0) return;

    // Toggle only for highlight + reference lines
    const meta = chart.getDatasetMeta(idx);
    meta.hidden = meta.hidden === null ? !chart.data.datasets[idx].hidden : null;
    chart.update();
  }

  function renderChartSingleDay(dateKey) {
    const day = state.data?.days?.[dateKey];
    const ctx = el("chart").getContext("2d");

    if (!day) {
      if (chart) chart.destroy();
      chart = null;
      el("summary").innerHTML = `<div>Inget dygn hittades för <b>${dateKey}</b>.</div>`;
      return;
    }

    const labels = buildDayLabels(day);
    const rawSeries = buildDaySeries(day);
    const series = state.fillGaps ? fillSmallGapsLinear(rawSeries, 8) : rawSeries;

    const stats = computeStats(series);

    const win2h = cheapestWindow(series, 8);
    const win4h = cheapestWindow(series, 16);
    const win8h = cheapestWindow(series, 32);

    const hi2 = buildHighlightSeries(series, win2h);
    const hi4 = buildHighlightSeries(series, win4h);
    const hi8 = buildHighlightSeries(series, win8h);

    const datasets = [
      {
        label: unitLabel(),
        data: series,
        spanGaps: false,
        pointRadius: 0,
        borderWidth: 2,
        tension: 0.2,
        borderColor: lineGradientColor,
        borderJoinStyle: "round",
        borderCapStyle: "round"
      }
    ];

    // Highlight order: 8h -> 4h -> 2h (so 2h sits on top)
    if (hi8) datasets.push({ label: "Billigaste 8h", data: hi8, pointRadius: 0, borderWidth: 6, tension: 0.2, borderColor: "rgba(255,255,255,0.40)" });
    if (hi4) datasets.push({ label: "Billigaste 4h", data: hi4, pointRadius: 0, borderWidth: 5, tension: 0.2, borderColor: "rgba(120,220,255,0.85)" });
    if (hi2) datasets.push({ label: "Billigaste 2h", data: hi2, pointRadius: 0, borderWidth: 6, tension: 0.2, borderColor: "rgba(255,215,120,0.95)" });

    // Reference lines 1/2/3 kr/kWh converted to current metric
    if (state.krLines) {
      const y1 = sekKwhToMetricY(1);
      const y2 = sekKwhToMetricY(2);
      const y3 = sekKwhToMetricY(3);

      const addH = (y, label) => {
        if (typeof y !== "number" || Number.isNaN(y)) return;
        datasets.push({
          label,
          data: labels.map(() => y),
          pointRadius: 0,
          borderWidth: 1,
          borderDash: [4,4],
          borderColor: "rgba(255,255,255,0.25)"
        });
      };

      addH(y1, "≈ 1 kr/kWh");
      addH(y2, "≈ 2 kr/kWh");
      addH(y3, "≈ 3 kr/kWh");
    }

    const title = `${dateKey} (${unitLabel()}) – present ${day.present}/${day.expected}` +
      (state.fillGaps ? " (extrapolerat ≤8 null)" : "");

    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: "line",
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { display: true, onClick: legendOnClick },
          title: { display: true, text: title },
          tooltip: {
            enabled: true,
            callbacks: {
              title: (items) => items?.[0]?.label || "",
              label: (c) => {
                const v = c.parsed?.y;
                if (v === null || v === undefined || Number.isNaN(v)) return "—";
                return `${c.dataset.label}: ${v.toFixed(decimals())}`;
              },
              afterLabel: (c) => {
                const idx = c.dataIndex;
                const p = day?.points?.[idx];
                if (!p?.utc) return "";
                const note = (p && typeof p[state.metric] === "number")
                  ? ""
                  : (state.fillGaps ? " (extrapolerad punkt)" : " (saknas i rådata)");
                return `UTC: ${p.utc}${note}`;
              }
            }
          }
        },
        scales: {
          x: { ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 12 } },
          y: { title: { display: true, text: unitLabel() } }
        }
      }
    });

    renderSummary({
      stats,
      win2h,
      win4h,
      win8h,
      infoText: `Dygn: <b>${dateKey}</b> (${day.resolutionMinutes ?? "—"} min)`,
      timeText2h: windowTimeTextSingleDay(dateKey, day, win2h),
      timeText4h: windowTimeTextSingleDay(dateKey, day, win4h),
      timeText8h: windowTimeTextSingleDay(dateKey, day, win8h),
    });
  }

  function renderChartRange(nDays) {
    const ctx = el("chart").getContext("2d");
    const keys = buildRangeKeys(nDays);

    if (!keys.length) {
      if (chart) chart.destroy();
      chart = null;
      el("summary").innerHTML = `<div>Ingen historik hittades.</div>`;
      return;
    }

    const { labels, series: rawSeries, refs } = buildRangeLabelsAndSeries(keys);
    const series = state.fillGaps ? fillSmallGapsLinear(rawSeries, 8) : rawSeries;

    const stats = computeStats(series);

    const win2h = cheapestWindow(series, 8);
    const win4h = cheapestWindow(series, 16);
    const win8h = cheapestWindow(series, 32);

    const hi2 = buildHighlightSeries(series, win2h);
    const hi4 = buildHighlightSeries(series, win4h);
    const hi8 = buildHighlightSeries(series, win8h);

    const datasets = [
      {
        label: `${unitLabel()} (${nDays}d)`,
        data: series,
        spanGaps: false,
        pointRadius: 0,
        borderWidth: 2,
        tension: 0.15,
        borderColor: lineGradientColor,
        borderJoinStyle: "round",
        borderCapStyle: "round"
      }
    ];

    if (hi8) datasets.push({ label: "Billigaste 8h", data: hi8, pointRadius: 0, borderWidth: 6, tension: 0.15, borderColor: "rgba(255,255,255,0.40)" });
    if (hi4) datasets.push({ label: "Billigaste 4h", data: hi4, pointRadius: 0, borderWidth: 5, tension: 0.15, borderColor: "rgba(120,220,255,0.85)" });
    if (hi2) datasets.push({ label: "Billigaste 2h", data: hi2, pointRadius: 0, borderWidth: 6, tension: 0.15, borderColor: "rgba(255,215,120,0.95)" });

    if (state.krLines) {
      const y1 = sekKwhToMetricY(1);
      const y2 = sekKwhToMetricY(2);
      const y3 = sekKwhToMetricY(3);

      const addH = (y, label) => {
        if (typeof y !== "number" || Number.isNaN(y)) return;
        datasets.push({
          label,
          data: labels.map(() => y),
          pointRadius: 0,
          borderWidth: 1,
          borderDash: [4,4],
          borderColor: "rgba(255,255,255,0.25)"
        });
      };

      addH(y1, "≈ 1 kr/kWh");
      addH(y2, "≈ 2 kr/kWh");
      addH(y3, "≈ 3 kr/kWh");
    }

    const title = `Senaste ${nDays} dagar (${unitLabel()})` + (state.fillGaps ? " (extrapolerat ≤8 null)" : "");

    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: "line",
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { display: true, onClick: legendOnClick },
          title: { display: true, text: title },
          tooltip: {
            enabled: true,
            callbacks: {
              title: (items) => items?.[0]?.label || "",
              label: (c) => {
                const v = c.parsed?.y;
                if (v === null || v === undefined || Number.isNaN(v)) return "—";
                return `${c.dataset.label}: ${v.toFixed(decimals())}`;
              }
            }
          }
        },
        scales: {
          x: { ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 } },
          y: { title: { display: true, text: unitLabel() } }
        }
      }
    });

    renderSummary({
      stats,
      win2h,
      win4h,
      win8h,
      infoText: `Intervall: <b>${keys[0]}</b> → <b>${keys[keys.length-1]}</b>`,
      timeText2h: windowTimeTextRange(refs, win2h),
      timeText4h: windowTimeTextRange(refs, win4h),
      timeText8h: windowTimeTextRange(refs, win8h),
    });
  }

  function render() {
    // Ensure day dropdown always populated
    if (!state.data?.days) return;

    if (state.tab === "today") {
      state.selectedDate = stockholmTodayIsoDate();
      el("datePick").value = state.selectedDate || "";
      renderChartSingleDay(state.selectedDate);
      return;
    }

    if (state.tab === "tomorrow") {
      const tmr = addDays(stockholmTodayIsoDate(), 1);
      state.selectedDate = tmr;
      el("datePick").value = state.selectedDate || "";
      renderChartSingleDay(state.selectedDate);
      return;
    }

    if (state.tab === "day") {
      state.selectedDate = el("datePick").value || state.selectedDate;
      el("datePick").value = state.selectedDate || "";
      renderChartSingleDay(state.selectedDate);
      return;
    }

    if (state.tab === "7d") return renderChartRange(7);
    if (state.tab === "14d") return renderChartRange(14);
    if (state.tab === "30d") return renderChartRange(30);
  }

  function setTab(tab) {
    state.tab = tab;

    const ids = ["today","tomorrow","day","7d","14d","30d"];
    ids.forEach(t => el(`tab-${t}`).classList.toggle("active", tab === t));

    render();
  }

  function renderMeta() {
    const m = state.data?.meta;
    if (!m) { el("meta").textContent = ""; return; }

    el("meta").innerHTML = `
      <div class="row">
        <span class="pill">area: <b>${m.area}</b></span>
        <span class="pill">documentType: <b>${m.documentType}</b></span>
        <span class="pill">tz: <b>${m.timeZone}</b></span>
        <span class="pill">EUR/SEK: <b>${m.eursek}</b> (${m.eursekDate})</span>
        <span class="pill">updatedAt: <b>${m.updatedAt}</b></span>
      </div>
      <div class="small" style="margin-top:8px;">
        request: ${m.request?.periodStart ?? "—"} → ${m.request?.periodEnd ?? "—"}
      </div>
    `;
  }

  function populateDatePick() {
    const days = state.data?.days || {};
    const keys = Object.keys(days).sort();
    const dp = el("datePick");

    dp.innerHTML = keys.map(k => {
      const d = days[k];
      return `<option value="${k}">${k} (${d.present}/${d.expected})</option>`;
    }).join("");

    const today = stockholmTodayIsoDate();
    state.selectedDate = keys.includes(today) ? today : (keys[keys.length - 1] || null);
    dp.value = state.selectedDate || "";
  }

  async function loadHistory(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status} vid GET ${url}`);
    return await r.json();
  }

  function loadSettings() {
    const fg = localStorage.getItem("rossohamn_fillGaps");
    state.fillGaps = (fg === "1");
    el("fillGaps").checked = state.fillGaps;

    const kl = localStorage.getItem("rossohamn_krLines");
    state.krLines = (kl === "1");
    el("krLines").checked = state.krLines;
  }

  function saveSettings() {
    localStorage.setItem("rossohamn_fillGaps", state.fillGaps ? "1" : "0");
    localStorage.setItem("rossohamn_krLines", state.krLines ? "1" : "0");
  }

  function stepDay(delta) {
    const keys = Object.keys(state.data?.days || {}).sort();
    if (!keys.length) return;

    const current = el("datePick").value || state.selectedDate;
    const idx = keys.indexOf(current);
    if (idx === -1) return;

    const nextIdx = idx + delta;
    if (nextIdx < 0 || nextIdx >= keys.length) return;

    state.selectedDate = keys[nextIdx];
    el("datePick").value = state.selectedDate;
    setTab("day");
  }

  async function bootstrap() {
    const src = getParam("src") || DEFAULT_SRC;
    el("src").value = src;

    state.metric = el("metric").value;
    loadSettings();

    try {
      state.data = await loadHistory(src);
      renderMeta();
      populateDatePick();
      setTab("today");
    } catch (e) {
      el("meta").innerHTML = `<div style="color:#ff9a9a;"><b>Fel:</b> ${e.message}</div>`;
      if (chart) chart.destroy();
      chart = null;
      el("summary").innerHTML = "";
    }
  }

  // ----- Events -----
  el("reload").addEventListener("click", bootstrap);

  el("tab-today").addEventListener("click", () => setTab("today"));
  el("tab-tomorrow").addEventListener("click", () => setTab("tomorrow"));
  el("tab-day").addEventListener("click", () => setTab("day"));
  el("tab-7d").addEventListener("click", () => setTab("7d"));
  el("tab-14d").addEventListener("click", () => setTab("14d"));
  el("tab-30d").addEventListener("click", () => setTab("30d"));

  el("metric").addEventListener("change", () => {
    state.metric = el("metric").value;
    render();
  });

  el("datePick").addEventListener("change", () => {
    state.selectedDate = el("datePick").value;
    setTab("day");
  });

  el("fillGaps").addEventListener("change", () => {
    state.fillGaps = el("fillGaps").checked;
    saveSettings();
    render();
  });

  el("krLines").addEventListener("change", () => {
    state.krLines = el("krLines").checked;
    saveSettings();
    render();
  });

  el("prevDay").addEventListener("click", () => stepDay(-1));
  el("nextDay").addEventListener("click", () => stepDay(1));

  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") stepDay(-1);
    if (e.key === "ArrowRight") stepDay(1);
  });

  bootstrap();
})();
</script>
</body>
</html>
