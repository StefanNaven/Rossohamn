<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rossohamn – Spotpriser (SE3)</title>

  <!-- External CSS -->
  <link rel="stylesheet" href="styles.css">

  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div>
          <div style="font-size:18px; font-weight:700;">Rossohamn – Spotpriser</div>
          <div class="small">Källa: ENTSO-E A44 (SE3) → history.json</div>
        </div>
        <div class="row">
          <label class="small" for="src">Data-URL</label>
          <input id="src" style="min-width:180px; flex: 1 1 260px;" />
          <button id="reload" style="padding:8px 10px; border-radius:10px; border:1px solid #2a2a2a; background:#151515; color:#fff; cursor:pointer;">Ladda</button>
        </div>
      </div>

      <div id="meta" class="meta" style="margin-top:10px;"></div>
    </div>

    <div class="card">
      <div class="row tabs">
        <button id="tab-today" class="active">Idag</button>
        <button id="tab-tomorrow">Imorgon</button>
        <button id="tab-history">Historik</button>
        <button id="tab-last7">7 dagar</button>
        <span style="flex:1;"></span>

        <label class="small" for="metric">Serie</label>
        <select id="metric">
          <option value="oreKwh" selected>öre/kWh</option>
          <option value="sekKwh">SEK/kWh</option>
          <option value="eurMwh">EUR/MWh</option>
        </select>

        <label class="toggle small" title="Fyll bara korta luckor (max 8 null i rad) med linjär interpolation. Rådata ändras inte.">
          <input id="fillGaps" type="checkbox" />
          Extrapolera null (≤8)
        </label>

        <label class="toggle small" title="Lås Y-axeln så att maxvärdet (för aktuell vy) blir fast. Gör små skillnader lättare att se.">
          <input id="lockYMax" type="checkbox" />
          Lås Y-max
        </label>

        <label class="toggle small" title="Visa horisontella referenslinjer (1 kr, 2 kr, 3 kr) när du visar SEK/kWh.">
          <input id="showCostLines" type="checkbox" checked />
          1/2/3 kr-linjer
        </label>

        <label class="small" for="datePick">Datum</label>
        <div class="dayNav">
          <button id="prevDay" class="iconBtn" title="Föregående dag (←)">←</button>
          <select id="datePick"></select>
          <button id="nextDay" class="iconBtn" title="Nästa dag (→)">→</button>
        </div>
      </div>

      <div style="margin-top:10px;" class="chartWrap">
        <canvas id="chart"></canvas>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div style="font-weight:700;">Summering</div>
        <div class="small" id="summaryNote">Billigaste fönster kräver komplett fönster (inga null)</div>
      </div>
      <div id="summary" style="margin-top:10px;"></div>
    </div>

    <div class="card small">
      Tips: du kan byta datakälla via querystring: <span class="pill">?src=https://www.rossohamn.se/spotprices/history.json</span>
    </div>
  </div>

<script>
(() => {
  const DEFAULT_SRC = "history.json";
  const el = (id) => document.getElementById(id);

  const state = {
    data: null,
    tab: "today",
    selectedDate: null,
    metric: "oreKwh",
    fillGaps: false,
    lockYMax: false,
    showCostLines: true
  };

  let chart = null;

  function stockholmTodayIsoDate() {
    const parts = new Intl.DateTimeFormat("sv-SE", {
      timeZone: "Europe/Stockholm",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(new Date());

    const y = parts.find(p => p.type === "year").value;
    const m = parts.find(p => p.type === "month").value;
    const d = parts.find(p => p.type === "day").value;
    return `${y}-${m}-${d}`;
  }

  function addDaysIsoDate(isoDate, deltaDays) {
    const [y, m, d] = isoDate.split("-").map(Number);
    const dt = new Date(Date.UTC(y, m - 1, d));
    dt.setUTCDate(dt.getUTCDate() + deltaDays);
    const y2 = dt.getUTCFullYear();
    const m2 = String(dt.getUTCMonth() + 1).padStart(2, "0");
    const d2 = String(dt.getUTCDate()).padStart(2, "0");
    return `${y2}-${m2}-${d2}`;
  }

  function getParam(name) {
    const u = new URL(location.href);
    return u.searchParams.get(name);
  }

  function fmtNum(v, decimals = 2) {
    if (v === null || v === undefined || Number.isNaN(v)) return "—";
    return Number(v).toFixed(decimals);
  }

  function unitLabel() {
    switch (state.metric) {
      case "oreKwh": return "öre/kWh";
      case "sekKwh": return "SEK/kWh";
      case "eurMwh": return "EUR/MWh";
      default: return state.metric;
    }
  }

  function computeDailyStatsFromSeries(series) {
    const vals = series.filter(v => typeof v === "number");
    if (!vals.length) return { avg: null, min: null, max: null };
    const sum = vals.reduce((a, b) => a + b, 0);
    return { avg: sum / vals.length, min: Math.min(...vals), max: Math.max(...vals) };
  }

  // Fill only *small internal gaps* where we have a number on both sides.
  function fillSmallGapsLinear(series, maxGap) {
    const out = [...series];

    let i = 0;
    while (i < out.length) {
      if (typeof out[i] === "number") { i++; continue; }

      // gap start
      const gapStart = i;
      while (i < out.length && typeof out[i] !== "number") i++;
      const gapEnd = i - 1;
      const gapLen = gapEnd - gapStart + 1;

      // Need left/right anchor numbers
      const leftIdx = gapStart - 1;
      const rightIdx = i;
      if (gapLen <= maxGap && leftIdx >= 0 && rightIdx < out.length) {
        const left = out[leftIdx];
        const right = out[rightIdx];
        if (typeof left === "number" && typeof right === "number") {
          const step = (right - left) / (gapLen + 1);
          for (let k = 1; k <= gapLen; k++) {
            out[gapStart + (k - 1)] = left + step * k;
          }
        }
      }
    }
    return out;
  }

  function buildLabelsForDay(day) {
    return day.points.map(p => p ? p.time : "");
  }

  function buildSeriesForDay(day) {
    return day.points.map(p => (p && typeof p[state.metric] === "number") ? p[state.metric] : null);
  }

  function cheapestWindowFromSeries(day, series, slots) {
    let best = null;

    for (let i = 0; i <= series.length - slots; i++) {
      let ok = true;
      let sum = 0;

      for (let k = 0; k < slots; k++) {
        const v = series[i + k];
        if (typeof v !== "number") { ok = false; break; }
        sum += v;
      }
      if (!ok) continue;

      const avg = sum / slots;
      if (!best || avg < best.avg) best = { startIdx: i, endIdx: i + slots - 1, avg };
    }

    if (!best) return null;

    const startTime = day.points[best.startIdx]?.time ?? "";
    const endTime = day.points[best.endIdx]?.time ?? "";
    return { ...best, startTime, endTime };
  }

  function buildHighlightSeries(series, win) {
    if (!win) return null;
    const out = series.map(() => null);
    for (let i = win.startIdx; i <= win.endIdx; i++) out[i] = series[i];
    return out;
  }

  function horizontalLine(value, len, label) {
    return {
      label,
      data: Array(len).fill(value),
      borderColor: "rgba(255,255,255,0.25)",
      borderWidth: 1,
      borderDash: [4, 4],
      pointRadius: 0,
      tension: 0
    };
  }

  const nowLinePlugin = {
    id: "nowLine",
    afterDraw(chart) {
      // Only show for "today"-tab AND when the rendered date actually is today's date.
      if (state.tab !== "today") return;
      const today = stockholmTodayIsoDate();
      if (state.selectedDate !== today) return;

      const now = new Date();
      const hh = now.getHours();
      const mm = now.getMinutes();
      const slot = hh * 4 + Math.floor(mm / 15); // 15-min slots

      const xScale = chart.scales.x;
      if (!xScale) return;
      const x = xScale.getPixelForValue(slot);

      const ctx = chart.ctx;
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, chart.chartArea.top);
      ctx.lineTo(x, chart.chartArea.bottom);
      ctx.stroke();
      ctx.restore();
    }
  };

  function setActiveTabButton(tab) {
    ["today", "tomorrow", "history", "last7"].forEach(t => {
      const b = el(`tab-${t === "last7" ? "last7" : t}`);
      if (!b) return;
      b.classList.toggle("active", t === tab);
    });
  }

  function setTab(tab) {
    state.tab = tab;
    setActiveTabButton(tab);

    // Pick a date automatically for today/tomorrow, otherwise keep selected.
    const keys = Object.keys(state.data?.days || {}).sort();
    if (!keys.length) return;

    const today = stockholmTodayIsoDate();

    if (tab === "today") {
      state.selectedDate = keys.includes(today) ? today : keys[keys.length - 1];
      el("datePick").value = state.selectedDate;
      renderChartForDate(state.selectedDate);
      return;
    }

    if (tab === "tomorrow") {
      const tomorrow = addDaysIsoDate(today, 1);
      // If we have tomorrow, use it; otherwise fall back to latest available.
      state.selectedDate = keys.includes(tomorrow) ? tomorrow : keys[keys.length - 1];
      el("datePick").value = state.selectedDate;
      renderChartForDate(state.selectedDate);
      return;
    }

    if (tab === "history") {
      if (!state.selectedDate) state.selectedDate = keys[keys.length - 1];
      el("datePick").value = state.selectedDate;
      renderChartForDate(state.selectedDate);
      return;
    }

    if (tab === "last7") {
      if (!state.selectedDate) state.selectedDate = keys[keys.length - 1];
      el("datePick").value = state.selectedDate;
      renderChartLastNDays(7, state.selectedDate);
      return;
    }
  }

  function stepDay(delta) {
    const keys = Object.keys(state.data?.days || {}).sort();
    if (!keys.length) return;

    if (!state.selectedDate) state.selectedDate = keys[keys.length - 1];
    const idx = keys.indexOf(state.selectedDate);
    if (idx === -1) return;

    const nextIdx = idx + delta;
    if (nextIdx < 0 || nextIdx >= keys.length) return;

    state.selectedDate = keys[nextIdx];
    el("datePick").value = state.selectedDate;

    // Keep current view type, but ensure it renders correctly
    if (state.tab === "last7") {
      renderChartLastNDays(7, state.selectedDate);
    } else {
      setTab("history");
    }
  }

  function buildLineGradient(ctx, chartArea) {
    const g = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
    // rainbow-ish: green (low) -> blue (mid) -> red (high)
    g.addColorStop(0.00, "rgba(0,255,140,0.95)");
    g.addColorStop(0.55, "rgba(0,160,255,0.95)");
    g.addColorStop(1.00, "rgba(255,70,70,0.95)");
    return g;
  }

  function buildChart(title, labels, datasets, ySuggestedMax) {
    const ctx = el("chart").getContext("2d");
    if (chart) chart.destroy();

    chart = new Chart(ctx, {
      type: "line",
      data: { labels, datasets },
      plugins: [nowLinePlugin],
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },

        plugins: {
          legend: { display: true },
          title: { display: true, text: title },
          tooltip: { enabled: true }
        },

        scales: {
          x: {
            ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 12 },
            grid: { color: "rgba(255,255,255,0.06)" }
          },
          y: {
            title: { display: true, text: unitLabel() },
            suggestedMax: ySuggestedMax ?? undefined,
            grid: { color: "rgba(255,255,255,0.06)" }
          }
        }
      }
    });
  }

  function renderSummary(stats, win2h, win4h, win8h, extrapolatedCount) {
    el("summaryNote").textContent = state.fillGaps
      ? "Billigaste fönster kan använda extrapolerade punkter (≤8 null i rad). Rådata ändras inte."
      : "Billigaste fönster kräver komplett fönster (inga null).";

    const dec = (state.metric === "oreKwh") ? 2 : 4;

    el("summary").innerHTML = `
      <div class="row">
        <span class="pill">Medel: <b>${fmtNum(stats.avg, dec)}</b> ${unitLabel()}</span>
        <span class="pill">Min: <b>${fmtNum(stats.min, dec)}</b></span>
        <span class="pill">Max: <b>${fmtNum(stats.max, dec)}</b></span>
        ${state.fillGaps
          ? `<span class="pill">Extrapolering: <b>ON</b> (antal punkter: ${extrapolatedCount})</span>`
          : `<span class="pill">Extrapolering: <b>OFF</b></span>`}
      </div>

      <table style="margin-top:10px;">
        <thead><tr><th>Fönster</th><th>Medel</th><th>Tid</th><th>Not</th></tr></thead>
        <tbody>
          <tr>
            <td>Billigaste 2h</td>
            <td>${win2h ? `<b>${fmtNum(win2h.avg, dec)}</b> ${unitLabel()}` : "—"}</td>
            <td>${win2h ? `${win2h.startTime} → ${win2h.endTime}` : "—"}</td>
            <td>${win2h ? (state.fillGaps ? "Kan inkludera extrapolerade punkter" : "Endast rådata utan null") : "Inget komplett 2h-fönster"}</td>
          </tr>
          <tr>
            <td>Billigaste 4h</td>
            <td>${win4h ? `<b>${fmtNum(win4h.avg, dec)}</b> ${unitLabel()}` : "—"}</td>
            <td>${win4h ? `${win4h.startTime} → ${win4h.endTime}` : "—"}</td>
            <td>${win4h ? (state.fillGaps ? "Kan inkludera extrapolerade punkter" : "Endast rådata utan null") : "Inget komplett 4h-fönster"}</td>
          </tr>
          <tr>
            <td>Billigaste 8h</td>
            <td>${win8h ? `<b>${fmtNum(win8h.avg, dec)}</b> ${unitLabel()}` : "—"}</td>
            <td>${win8h ? `${win8h.startTime} → ${win8h.endTime}` : "—"}</td>
            <td>${win8h ? (state.fillGaps ? "Kan inkludera extrapolerade punkter" : "Endast rådata utan null") : "Inget komplett 8h-fönster"}</td>
          </tr>
        </tbody>
      </table>
    `;
  }

  function countExtrapolated(rawSeries, filledSeries) {
    let c = 0;
    for (let i = 0; i < rawSeries.length; i++) {
      if (rawSeries[i] === null && typeof filledSeries[i] === "number") c++;
    }
    return c;
  }

  function renderChartForDate(dateKey) {
    const day = state.data?.days?.[dateKey];
    if (!day) return;

    const labels = buildLabelsForDay(day);
    const rawSeries = buildSeriesForDay(day);
    const series = state.fillGaps ? fillSmallGapsLinear(rawSeries, 8) : rawSeries;

    const extrapolatedCount = state.fillGaps ? countExtrapolated(rawSeries, series) : 0;

    const stats = computeDailyStatsFromSeries(series);

    const win2h = cheapestWindowFromSeries(day, series, 8);
    const win4h = cheapestWindowFromSeries(day, series, 16);
    const win8h = cheapestWindowFromSeries(day, series, 32);

    const hi8 = buildHighlightSeries(series, win8h);

    const maxVal = stats.max;
    const ySuggestedMax = state.lockYMax && typeof maxVal === "number" ? maxVal * 1.05 : undefined;

    // Build datasets
    const ctx = el("chart").getContext("2d");
    const lineGradientColor = (chart && chart.chartArea)
      ? buildLineGradient(ctx, chart.chartArea)
      : "rgba(0,160,255,0.95)";

    const datasets = [
      {
        label: unitLabel(),
        data: series,
        spanGaps: false,
        pointRadius: 0,
        borderWidth: 2,
        tension: 0.2,
        borderColor: lineGradientColor,
        borderJoinStyle: "round",
        borderCapStyle: "round"
      }
    ];

    if (hi8) {
      datasets.push({
        label: "Billigaste 8h",
        data: hi8,
        spanGaps: false,
        pointRadius: 0,
        borderWidth: 5,
        tension: 0.2,
        borderColor: "rgba(255,255,255,0.85)"
      });
    }

    if (state.metric === "sekKwh" && state.showCostLines) {
      datasets.push(horizontalLine(1, labels.length, "1 kr"));
      datasets.push(horizontalLine(2, labels.length, "2 kr"));
      datasets.push(horizontalLine(3, labels.length, "3 kr"));
    }

    const title = `${dateKey} (${unitLabel()}) – present ${day.present}/${day.expected}` +
      (state.fillGaps ? " (extrapolerat ≤8 null)" : "");

    buildChart(title, labels, datasets, ySuggestedMax);
    renderSummary(stats, win2h, win4h, win8h, extrapolatedCount);
  }

  function buildLastNDaysSeries(n, endDateKey) {
    const days = state.data?.days || {};
    const keys = Object.keys(days).sort();
    if (!keys.length) return null;

    const endIdx = keys.indexOf(endDateKey);
    const lastKeys = (endIdx >= 0 ? keys.slice(Math.max(0, endIdx - (n - 1)), endIdx + 1) : keys.slice(-n));

    const labels = [];
    const raw = [];
    lastKeys.forEach(dk => {
      const day = days[dk];
      day.points.forEach(p => {
        labels.push(`${dk} ${p ? p.time : ""}`);
        raw.push((p && typeof p[state.metric] === "number") ? p[state.metric] : null);
      });
    });

    return { labels, raw, lastKeys };
  }

  function renderChartLastNDays(n, endDateKey) {
    const built = buildLastNDaysSeries(n, endDateKey);
    if (!built) return;

    const { labels, raw, lastKeys } = built;
    const series = state.fillGaps ? fillSmallGapsLinear(raw, 8) : raw;
    const extrapolatedCount = state.fillGaps ? countExtrapolated(raw, series) : 0;

    const stats = computeDailyStatsFromSeries(series);

    // Cheapest 8h across the whole last-N view (still 15-min resolution => 32 slots)
    const fauxDay = { points: labels.map((lab, idx) => ({ time: lab.split(" ").slice(1).join(" ") })) };
    const win8 = cheapestWindowFromSeries(fauxDay, series, 32);
    const hi8 = buildHighlightSeries(series, win8);

    const maxVal = stats.max;
    const ySuggestedMax = state.lockYMax && typeof maxVal === "number" ? maxVal * 1.05 : undefined;

    const ctx = el("chart").getContext("2d");
    const lineGradientColor = (chart && chart.chartArea)
      ? buildLineGradient(ctx, chart.chartArea)
      : "rgba(0,160,255,0.95)";

    const datasets = [
      {
        label: `${unitLabel()} (${lastKeys[0]} → ${lastKeys[lastKeys.length - 1]})`,
        data: series,
        spanGaps: false,
        pointRadius: 0,
        borderWidth: 2,
        tension: 0.2,
        borderColor: lineGradientColor,
        borderJoinStyle: "round",
        borderCapStyle: "round"
      }
    ];

    if (hi8) {
      datasets.push({
        label: "Billigaste 8h (i vyn)",
        data: hi8,
        spanGaps: false,
        pointRadius: 0,
        borderWidth: 5,
        tension: 0.2,
        borderColor: "rgba(255,255,255,0.85)"
      });
    }

    if (state.metric === "sekKwh" && state.showCostLines) {
      datasets.push(horizontalLine(1, labels.length, "1 kr"));
      datasets.push(horizontalLine(2, labels.length, "2 kr"));
      datasets.push(horizontalLine(3, labels.length, "3 kr"));
    }

    const title = `${n} dagar (${unitLabel()}) – ${lastKeys[0]} → ${lastKeys[lastKeys.length - 1]}` +
      (state.fillGaps ? " (extrapolerat ≤8 null)" : "");

    buildChart(title, labels, datasets, ySuggestedMax);

    // Summary: show only "window 8h" for the view; keep 2h/4h as "—" to avoid confusion.
    renderSummary(stats, null, null, win8 ? { ...win8, startTime: labels[win8.startIdx], endTime: labels[win8.endIdx] } : null, extrapolatedCount);
  }

  function renderMeta() {
    const m = state.data?.meta;
    if (!m) { el("meta").textContent = ""; return; }

    el("meta").innerHTML = `
      <div class="row">
        <span class="pill">area: <b>${m.area}</b></span>
        <span class="pill">documentType: <b>${m.documentType}</b></span>
        <span class="pill">tz: <b>${m.timeZone}</b></span>
        <span class="pill">EUR/SEK: <b>${m.eursek}</b> (${m.eursekDate})</span>
        <span class="pill">updatedAt: <b>${m.updatedAt}</b></span>
      </div>
      <div class="small" style="margin-top:8px;">
        request: ${m.request?.periodStart ?? "—"} → ${m.request?.periodEnd ?? "—"}
      </div>
    `;
  }

  function populateDatePick() {
    const days = state.data?.days || {};
    const keys = Object.keys(days).sort();
    const dp = el("datePick");
    dp.innerHTML = keys.map(k => `<option value="${k}">${k} (${days[k].present}/${days[k].expected})</option>`).join("");

    const today = stockholmTodayIsoDate();
    if (keys.includes(today)) state.selectedDate = today;
    else state.selectedDate = keys[keys.length - 1] || null;

    dp.value = state.selectedDate || "";
  }

  async function loadHistory(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status} vid GET ${url}`);
    return await r.json();
  }

  function loadSettings() {
    state.fillGaps = (localStorage.getItem("rossohamn_fillGaps") === "1");
    state.lockYMax = (localStorage.getItem("rossohamn_lockYMax") === "1");
    state.showCostLines = (localStorage.getItem("rossohamn_showCostLines") !== "0"); // default ON

    el("fillGaps").checked = state.fillGaps;
    el("lockYMax").checked = state.lockYMax;
    el("showCostLines").checked = state.showCostLines;
  }

  function saveSetting(key, val) {
    localStorage.setItem(key, val ? "1" : "0");
  }

  async function bootstrap() {
    const src = getParam("src") || DEFAULT_SRC;
    el("src").value = src;

    state.metric = el("metric").value;
    loadSettings();

    try {
      state.data = await loadHistory(src);
      renderMeta();
      populateDatePick();
      setTab("today");
    } catch (e) {
      el("meta").innerHTML = `<div style="color:#ff9a9a;"><b>Fel:</b> ${e.message}</div>`;
      if (chart) chart.destroy();
      chart = null;
    }
  }

  // ===== UI wiring =====
  el("reload").addEventListener("click", async () => {
    const src = el("src").value.trim() || DEFAULT_SRC;
    try {
      state.data = await loadHistory(src);
      renderMeta();
      populateDatePick();
      setTab(state.tab);
    } catch (e) {
      el("meta").innerHTML = `<div style="color:#ff9a9a;"><b>Fel:</b> ${e.message}</div>`;
      if (chart) chart.destroy();
      chart = null;
    }
  });

  el("metric").addEventListener("change", () => {
    state.metric = el("metric").value;
    if (state.tab === "last7") renderChartLastNDays(7, state.selectedDate);
    else if (state.selectedDate) renderChartForDate(state.selectedDate);
  });

  el("tab-today").addEventListener("click", () => setTab("today"));
  el("tab-tomorrow").addEventListener("click", () => setTab("tomorrow"));
  el("tab-history").addEventListener("click", () => setTab("history"));
  el("tab-last7").addEventListener("click", () => setTab("last7"));

  el("datePick").addEventListener("change", () => {
    state.selectedDate = el("datePick").value;
    if (state.tab === "last7") renderChartLastNDays(7, state.selectedDate);
    else setTab("history");
  });

  el("fillGaps").addEventListener("change", () => {
    state.fillGaps = el("fillGaps").checked;
    saveSetting("rossohamn_fillGaps", state.fillGaps);
    if (state.tab === "last7") renderChartLastNDays(7, state.selectedDate);
    else if (state.selectedDate) renderChartForDate(state.selectedDate);
  });

  el("lockYMax").addEventListener("change", () => {
    state.lockYMax = el("lockYMax").checked;
    saveSetting("rossohamn_lockYMax", state.lockYMax);
    if (state.tab === "last7") renderChartLastNDays(7, state.selectedDate);
    else if (state.selectedDate) renderChartForDate(state.selectedDate);
  });

  el("showCostLines").addEventListener("change", () => {
    state.showCostLines = el("showCostLines").checked;
    saveSetting("rossohamn_showCostLines", state.showCostLines);
    if (state.tab === "last7") renderChartLastNDays(7, state.selectedDate);
    else if (state.selectedDate) renderChartForDate(state.selectedDate);
  });

  el("prevDay").addEventListener("click", () => stepDay(-1));
  el("nextDay").addEventListener("click", () => stepDay(1));

  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") stepDay(-1);
    if (e.key === "ArrowRight") stepDay(1);
  });

  bootstrap();
})();
</script>
</body>
</html>
